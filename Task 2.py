# 2. Написать программу сложения и умножения двух шестнадцатеричных чисел.
# При этом каждое число представляется как массив, элементы которого это цифры
# числа. Например, пользователь ввёл A2 и C4F. Сохранить их как [‘A’, ‘2’] и
# [‘C’, ‘4’, ‘F’] соответственно. Сумма чисел из примера: [‘C’, ‘F’, ‘1’],
# произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].

# Я извиняюсь - Вы сказали посчитать сумму и произведение в столбик, но я чето
# вдруг вспомнил свой школьный курс основ арифметики, проностальгировался и
# захотель воспользоваться этими знаниями.
# Арифметика базируется на 2х аксиоматических понятиях - начало (ноль или один)
# и увеличение на единицу. Этого достаточно, чтобы написать и сложение,
# и умножение (и вычитание, с делением по сложнее).
# У меня есть четыре недостатка (которые я нашёл):
# 1. Это работает ОЧЕНЬ медленно, использовав вычисления в столбик можно было
#    бы ускориться в тысячи раз. Мне пришлось ждать около 5ти минут, прежде
#    чем посчиталось умножения чисел из условия (причем, если второе число
#    меньше, иначе считаться будет намного дольше - я принципиально не хотел
#    разворачивать множители, чтобы на малых числах можно было убедиться,
#    что множители можно менять местами).
# 2. Я не стал заморачиваться с отрицательными числами.
#    Это не так сложно, но я подумал, что это может оказаться излишним.
# 3. Я решил не парится по поводу регистра и везде работаю так, как будто ввели
#    числа большими буквами
# 4. Хоть я решил не заморачиваться с регистрами и минусами, потому что мне это
#    было не интересно, но я почему-то вдруг решил сделать так, чтобы можно
#    было легко перейти на счёт в другой системе счисления.
#
# Выполнил я в таком виде по собственной прихоти, если так нельзя из-за
# недостатков (алгоритм-то плохой), то в конце приведены функции, которые
# складывают и умножают в столбик как доказательство того, что я могу.
# Кстати, если добавить кэширование, то скорость, мне кажется, значительно
# возрастёт для любого алгоритма, но я так понял, что пока нам ещё рано
# так делать.
#
# Числа я храню в обратной записи - в начале массива младший разряд


from collections import deque


# Эта функция отражает все особенности 16ричной системы счисления
def inc16(char):
    digits = '0123456789ABCDEF0'
    return digits[digits.index(char)+1], char == 'F'


# Эта функция увеличивает число на 1 в соотвествии с правилами функции,
# переданной в первом параметре
def sc(inc, n, pos=0):
    if len(n) == pos:
        n.append('1')
    else:
        n[pos], b_over = inc(n[pos])
        if b_over:
            sc(inc, n, pos+1)


# Проверка на равенство
def equals(n1, n2):
    if len(n1) != len(n2):
        return False
    for i in range(len(n1)):
        if n1[i] != n2[i]:
            return False
    return True


# Функция сложения, а если ввести минус, то и вычитания
def add(inc, n1, n2):
    cnt = ['0']
    n2_copy = n2.copy()
    while not equals(cnt, n1):
        sc(inc, cnt)
        sc(inc, n2_copy)
    return n2_copy


# Обёртка функции сложения для 16-ричной системы
def add16(n1, n2):
    return add(inc16, n1, n2)


# Функция умножения
def mul(inc, n1, n2):
    cnt = ['0']
    result = ['0']
    while not equals(cnt, n2):
        result = add(inc, result, n1)
        sc(inc, cnt)
    return result


# Обёртка функции умножения для 16-ричной системы
def mul16(n1, n2):
    return mul(inc16, n1, n2)


# Т.к. в памяти хранится развёрнутое число в массиве, надо перед выводом
# его развернуть и склеить
def repr_num(n):
    n_copy = n.copy()
    n_copy.reverse()
    return "".join(n_copy)


# Стобиком сложение
def add_stolbik(n1, n2):
    def _add_one_register(ch1, ch2):
        digits = '0123456789ABCDEF0123456789ABCDE'
        idx = digits.index(ch1) + digits.index(ch2)
        return digits[idx], idx > 15
    b_over = False
    n1_copy = n1.copy()
    n2_copy = n2.copy()
    if len(n1_copy) < len(n2_copy):
        n1_copy += ['0'] * (len(n2_copy) - len(n1_copy))
    elif len(n1_copy) > len(n2_copy):
        n2_copy += ['0'] * (len(n1_copy) - len(n2_copy))
    result = ['0'] * len(n1_copy)
    for i in range(len(n1_copy)):
        if not b_over:
            result[i], b_over = _add_one_register(n1_copy[i], n2_copy[i])
        else:
            result[i], b_over = _add_one_register(n1_copy[i], n2_copy[i])
            if b_over:
                result[i], _ = _add_one_register(result[i], '1')
            else:
                result[i], b_over = _add_one_register(result[i], '1')
    if b_over:
        result.append('1')
    return result


# И умножение
def mul_stolbik(n1, n2):
    cnt = ['0']
    result = ['0']
    while not equals(cnt, n2):
        result = add_stolbik(result, n1)
        cnt = add_stolbik(cnt, ['1'])
    return result


n1 = deque(input("Введите натуральное число или "
                 "ноль в 16ричной системе: "))
n2 = deque(input("Введите ещё одно натуральное число или "
                 "ноль в 16ричной системе: "))
n1.reverse()
n2.reverse()
print(f"Сумма столбиком: {repr_num(add_stolbik(n1, n2))}")
print(f"Произведение столбиком: {repr_num(mul_stolbik(n1, n2))}")
print(f"Сумма методом давно забытых знаний: {repr_num(add16(n1, n2))}")
print(f"Произведение методом давно забытых знаний: {repr_num(mul16(n1, n2))}")
